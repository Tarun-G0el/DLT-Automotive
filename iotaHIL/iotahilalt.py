from multiprocessing import Process, Manager
	# The multiprocessing module provides a way to work with shared objects if they run under the control of a so-called manager.  A manager is a separate subprocess where the
	# real objects exist and which operates as a server.  Other processes access the shared objects through the use of proxies that operate as clients of the manager server.

import socket
	# For TCP servers, the socket object used to receive connections is not the same socket used to perform subsequent communication with the client.  In particular, the accept()
	# system call returns a new socket object that's actually used for the connection.  This allows a server to manage connections from a large number of clients simultaneously.
	
import threading as thread
import time

import os, sys
import subprocess
import traci

import random
import numpy
from cvxpy import *

import iotasetup as setup
import requests

from iota import *
from iota.adapter.wrappers import RoutingWrapper

def iota_transaction(light_id):
	response = requests.post('http://127.0.0.1:8080/request_light_address', json=light_id) # request an address for the corresponding light that is arriving
	service_addr = response.json()['address']
					
	api =\
	  Iota(
	    # Send PoW requests to local node.
	    # All other requests go to light wallet node.
	    RoutingWrapper('https://nodes.thetangle.org:443')
	      .add_route('attachToTangle', 'http://localhost:14265'),

	    # Seed used for cryptographic functions.
	    seed = b'CABREEMIRYLXLSWDLPUKFAMWMVBJYUIYQFBQGEE9BSCBCVOXXSTAXISQXGUIDPWZENEIYJNSXCGNHLRXG'
	  )

	# Example of sending a transfer using the adapter.
	send_transfer_response = api.send_transfer(
	  depth = 1, #100
	    transfers = [
	      ProposedTransaction(
	        # Recipient of the transfer.
	        address =
	          Address(service_addr),

	        # Amount of IOTA to transfer.
	        # This value may be zero.
	        value = 0,

	        # Optional tag to attach to the transfer.
	        tag = Tag(b'9999999999999999'),

	        # Optional message to include with the transfer.
	        message = TryteString.from_string('transaction made'),
	      ),
	    ],
	)
	bundle = send_transfer_response['bundle']
	for i in range(len(bundle.transactions)):
		transaction = bundle.transactions[i]
		if transaction.address == service_addr: # transaction.address is the address associated with this transaction
			TRANSACTION_ID = str(transaction.hash) # the transaction hash is used to uniquely identify the transaction on the Tangle; the value is generated by taking a hash of the raw transaction trits
												   # we assume in the code here that a single transaction was made to the recipient's address; otherwise, the code must be modified so that multiple TRANSACTION_IDs are stored
			print ('{}. Transaction ID: {}'.format(i+1, TRANSACTION_ID))
		else:
			TRANSACTION_ID = 'This transaction was not intended for the client.'
			print ('{}. {}'.format(i+1, TRANSACTION_ID))
	
	response = {}
	response['transaction_id'] = TRANSACTION_ID # string
	final = requests.post('http://127.0.0.1:8080/request_transaction_read', json=response) # request an address for the corresponding light that is arriving

def iota_return(jsobj):
	response = requests.post('http://127.0.0.1:8080/return_token', json=jsobj) # request an address for the corresponding light that is arriving
	transaction_id_ret = response.json()['transaction_id']
	print('Transaction of return ID is ', transaction_id_ret)

if __name__ == '__main__':

	# constants
	endSim = 400000 # the simulation will be permitted to run for a total of endSim milliseconds
	timeout = 0.1 # a floating point number [s]
	FLAGHELLOSMARTPHONEDATA = False
	
	# initialisations
	step = 0 # time step
	ticket = 1 # used to provide unique IDs to real vehicles
	

	participants = [] # a list of vehicles participating in the service
	newSpeed = []
	controlHistory = []
	removedParticipants = []
	realVehicles = []
	transactionBools = {}
	rulesBools = {}
	rulesBools2 = {}

	print("")
	
	print ("Starting the main program.")
	print ("Connecting to SUMO via TraCI.")
	
	# import TraCI (to use the library, the <SUMO_HOME>/tools directory must be on the python load path)
	if 'SUMO_HOME' in os.environ:
		tools = os.path.join(os.environ['SUMO_HOME'], 'tools')
		sys.path.append(tools)
	else:   
		sys.exit("Please declare environment variable 'SUMO_HOME'.")
		
	# interface with SUMO from Python:  (i) begin by starting SUMO-GUI from within the python script;...
	PORT = 8813
	sumoBinary = "/Program Files (x86)/DLR/Sumo/bin/sumo-gui"
	sumoProcess = subprocess.Popen([sumoBinary, "-c", "iota.sumocfg", "--remote-port", str(PORT)], stdout=sys.stdout, stderr=sys.stderr)
		
	# ...then (ii) connect to the (waiting) simulation
	traci.init(PORT)
	
	# begin the simulation
	traci.simulationStep(10100) # perform the simulation until the time in the day indicated (in milliseconds) is reached; use for time steps of 0.1s
	
	while step < endSim:
	
		print ('Time step [ms]: {}'.format(step))
		# print 'Current simulation time [ms]: {}'.format(traci.simulation.getCurrentTime())
		vehicles = traci.vehicle.getIDList() # a list of vehicles currently running in the scenario
		# print 'No. of vehicles currently running in the scenario: {}'.format(len(vehicles)) # number of vehicles currently running in the scenario
		print ('Vehicles currently running in the scenario: {}'.format(vehicles))

		departed = traci.simulation.getDepartedIDList() # a list of vehicles which departed (were inserted into the road network) in this time step
		if departed: # does departed have a value?
			transactionBools[departed[0]] = False
			rulesBools[departed[0]] = False
			rulesBools2[departed[0]] = False
			print(departed, 'was added in this time step')

		arrived = traci.simulation.getArrivedIDList() # A list of ids of vehicles which arrived (have reached their destination and are removed from the road network) in this time step
		if arrived:	# Assumes that vehicles queue, enter instance one at a time, leave instance one at a time
			veh_id = arrived[0]
			if veh_id in transactionBools: # or in rulesBools
				del transactionBools[veh_id]
				del rulesBools[veh_id]
				del rulesBools2[veh_id]
				print(arrived, 'was removed in this time step')

		for i in range(len(vehicles)):	# checks the distance of all vehicles to the lights
			nexttl = traci.vehicle.getNextTLS(vehicles[i])
			if not nexttl: # is the list empty?
				print(vehicles[i], ' has crossed the traffic light.')
				rulesBools[vehicles[i]] = True # TODO add functionality for random cars to break the rules and update accordingly
				if rulesBools[vehicles[i]] == True and rulesBools2[vehicles[i]] == False:
					rulesBools2[vehicles[i]] = True
					print(vehicles[i], ' thank you for following the rules. Token return being processed.')
					veh_addr = {}
					veh_addr['Vehicle Index'] = vehicles[i][3]
					threads = thread.Thread(target=iota_return, args=[veh_addr])
					threads.daemon = True                            # Daemonize thread
					threads.start()
			else:
				print(vehicles[i],' distance to upcoming light is: ', nexttl[0][2], 'meters')
				if nexttl[0][2] < 50 and transactionBools[vehicles[i]] == False:	# bluetooth signal tuned to accept and react to signal strength values of -30dBm equivalent to 50m with LoS
					# make transaction at corresponding light
					print(vehicles[i], ' is close now. Making IOTA Transaction now. . .')
					transactionBools[vehicles[i]] = True
					light_id = {}
					light_id['Light Node'] = nexttl[0][0]
					threads = thread.Thread(target=iota_transaction, args=[light_id])
					threads.daemon = True                            # Daemonize thread
					threads.start()
					
		print("")
		
		# goto the next time step
		step += 100 # in milliseconds
		traci.simulationStep(10100+step) # perform the simulation until the time in the day indicated (in milliseconds) is reached; use for time steps of 0.1s
	
	print ("Shutting the server down.")
	serverThread.terminate()
	traci.close() # close the connection to SUMO